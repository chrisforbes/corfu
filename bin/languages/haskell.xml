<?xml version="1.0" encoding="utf-8"?>
<language>
	<pattern regex="--.*$" style="comment.haskell"/>
	<contextPattern style="comment.haskell" name="comment">
		<begin>
			<pattern regex="{-" style="comment.haskell"/>
		</begin>
		<ref target="comment"/>
		<end>
			<pattern regex="-}" style="comment.haskell"/>
		</end>
	</contextPattern>
	
	<pattern regex="\b(class|as|case|where|of|data|default|deriving|primitive)\b" style="keyword.haskell"/>
	<pattern regex="\b(do|forall|hiding|if|then|else|import|infix|infixl)\b" style="keyword.haskell"/>
	<pattern regex="\b(infixr|instance|let|in|module|newtype|qualified|type|where)\b" style="keyword.haskell"/>
	
	<pattern regex="\b(not|otherwise|maybe|either|fst|snd|curry|uncurry|compare)\b" style="func.haskell"/>
	<pattern regex="\b(max|min|succ|pred|toEnum|fromEnum|enumFrom|enumFromThen)\b" style="func.haskell"/>
	<pattern regex="\b(enumFromTo|enumFromThenTo|minBound|maxBound|negate|abs|signum)\b" style="func.haskell"/>
	<pattern regex="\b(fromInteger|toRational|quot|rem|div|mod|quotRem|divMod|toInteger)\b" style="func.haskell"/>
	<pattern regex="\b(recip|fromRational|pi|exp|log|sqrt|logBase|sin|cos|tan|asin|acos|atan)\b" style="func.haskell"/>
	<pattern regex="\b(sinh|cosh|tanh|asinh|acosh|atanh|properFraction|truncate|round|ceiling)\b" style="func.haskell"/>
	<pattern regex="\b(floor|floatRadix|floatDigits|floatRange|decodeFloat|encodeFloat|exponent)\b" style="func.haskell"/>
	<pattern regex="\b(significand|scaleFloat|isNaN|isInfinite|isDenormalized|isNegativeZero)\b" style="func.haskell"/>
	<pattern regex="\b(isIEEE|atan2|subtract|even|odd|gcd|lcm|fromIntegral|realToFrac|return)\b" style="func.haskell"/>
	<pattern regex="\b(fail|fmap|mapM|mapM_|sequence|sequence_|id|const|flip|until|asTypeOf|error)\b" style="func.haskell"/>
	<pattern regex="\b(undefined|seq|map|filter|head|last|tail|init|null|length|reverse)\b" style="func.haskell"/>
	<pattern regex="\b(foldl|foldr|foldl1|foldr1|and|or|any|all|sum|product|concat|concatMap)\b" style="func.haskell"/>
	<pattern regex="\b(maximum|minimum|scanl|scanl1|scanr|scanr1|iterate|repeat|cycle|take|drop)\b" style="func.haskell"/>
	<pattern regex="\b(splitAt|takeWhile|dropWhile|span|break|elem|notElem|lookup|zip|zip3)\b" style="func.haskell"/>
	<pattern regex="\b(zipWith|zipWith3|unzip|unzip3|lines|words|unlines|unwords|showPrec)\b" style="func.haskell"/>
	<pattern regex="\b(show|showList|shows|showChar|showString|showParen|readsPrec|readList)\b" style="func.haskell"/>
	<pattern regex="\b(reads|readParen|read|lex|putChar|putStr|putStrLn|print|getChar|getLine)\b" style="func.haskell"/>
	<pattern regex="\b(getContents|interact|readFile|writeFile|appendFile|readIO|readLn|ioError)\b" style="func.haskell"/>
	<pattern regex="\b(userError|catch)\b" style="func.haskell"/>
	
	<!--
	<pattern regex="\b(Bool|Maybe|Either|Ord|Ordering|Char|String|Eq|Enum|Bounded)\b" style="type.haskell"/>
	<pattern regex="\b(Int|Integer|Float|Double|Rational|Num|Real|Integral|Fractional)\b" style="type.haskell"/>
	<pattern regex="\b(Floating|RealFrac|RealFloat|Monad|Functor|Show|ShowS|Read|ReadS|IO)\b" style="type.haskell"/>
	<pattern regex="\b(IOError|IOException)\b" style="type.haskell"/>
	-->
	<pattern regex="\b[A-Z][A-Za-z01-9_']*\b" style="type.haskell"/>
	
	<contextPattern style="string.haskell">
		<begin>
			<pattern regex="&quot;" style="string.haskell" />
		</begin>
		<end>
			<pattern regex="(?&lt;!\\)(\\\\)*&quot;" style="string.haskell" />
		</end>
	</contextPattern>
	
	<pattern regex="'([^\\]|\\.|\\DEL|\\SO)'" style="string.haskell" />
	<pattern regex="\b\d+(\.\d+)?\b" style="number.haskell" />
</language>
